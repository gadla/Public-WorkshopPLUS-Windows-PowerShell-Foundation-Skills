<!DOCTYPE html>
<!-- saved from url=(0047)https://labondemand.com/LabProfile/Manual/LABID -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width">
    <title>Local Lab Instructions</title>


    <script src="./Content/jquery-2.1.4.min.js.download" type="text/javascript"></script>
    <script src="./Content/showdown.min.js.download"></script>
    <link rel="stylesheet" type="text/css" href="./Content/prettify.css">
    <script src="./Content/yaml.min.js.download"></script>
    <script src="./Content/LocalizeTo" type="text/javascript"></script>
    <link href="./Content/CloudClient.css" rel="stylesheet" type="text/css">
  
    <style type="text/css">
        body, html {
            font-family: Segoe UI,Tahoma,Verdana,Arial,sans-serif;
            font-size: 14px;
            padding: 0;
            margin: 0;
            background-color: #efefef;
            color: #000;
            height: 100%;
        }

        body {
            overflow:auto;
        }

        #outputWrapper {
            background-color: #efefef;
            min-height:100%;
        }

        .instructionsPreview {
            padding: 20px;
            height: 100%;
        }

        .instructionsPreview .page {
            position:relative;
            display: block !important;
            padding: 15px 20px;
            background-color:#fff;
            page-break-after: always;
            min-height:40px;
        }

        .instructionsPreview .page:not(:first-child) {
            margin-top:20px;
        }

        @media print {
            body, html{
                height:auto;
            }
            
            body {
                -webkit-print-color-adjust: exact;
            }

            div {
                page-break-inside: avoid;
            }

            #outputWrapper {
                background-color: transparent;
            }

            .instructionsPreview {
                padding: 0;
            }

            .instructionsPreview .page:not(:first-child) {
                margin-top: 0px;
            }

        }

        @page {
            margin-left: 1.5cm;
            margin-right: 1.5cm;
            margin-top: 1.5cm;
            margin-bottom: 1.5cm;
        }
    </style>
    <link id="themeStylesheet" href="./Content/Blue.css" rel="stylesheet">

</head>
<body>
    <div id="outputWrapper">
                <div id="instructions" class="instructionsPreview">
    </div>
    <input type="hidden" id="rawContent" value="
[TemplateVersion]:
&#39;1.1&#39;

[LODLabID]:
&#39;40027&#39;

[LODLabNumber]:
&#39;03 FS.Pipeline_Basics&#39;

[AdminPowerShell]:
```
powershell -NoProfile -command &quot;Start-Process powershell -Verb RunAs&quot;
exit
```

[AdminPowerShellISE]:
```
powershell -NoProfile -command &quot;Start-Process powershell_ise -Verb RunAs&quot;
exit
```

# Welcome student to the module: Pipeline Basics

The pipeline is used to send objects output by one cmdlet as input to another cmdlet for processing. The result is a very powerful command chain that is comprised of a series of simple commands.

Estimated time to complete this lab: **60 minutes**
## Module Objective

After completing this lab, you will be able to:

- Compose cmdlets into sequences to solve simple administrative problems
- Understand pipeline behavior and syntax.
- Analyze data to extract frequency trends
- Sort, group, manipulate and convert data

===

# Login to Windows 10 and Start the Lab

Login to **win10(wdt** machine with the given credentials. You can find them on the **Resources** pane.

Please login with Username: **+++Power+++** and Password: **+++Pa$$w0rd+++**

After logging in wait until you see the &quot;Lab preparation has been completed&quot; in the action center (This can take up to 2 minutes). If this does not popup you can click in the bottom right of the Vm to open the action center. Begin by opening Windows PowerShell ISE by right clicking on the PowerShell icon and selecting **Run ISE as an Administrator**, or by clicking @[Run ISE as Administrator.][AdminPowerShellISE]{shell visible}.

> [!TIP] **Notes about using the lab**
> - It might take a moment to start ISE if you click the above link
> - You can click the **+++Type Text+++** icon to enter the highlighted text at the position of the cursor in the virtual machine. You can also click on the **++Copyto Clipboard++** icon and then paste in at the desired destination.
> - Entering your code in the script pane of the ISE will allow for better troubleshooting if you find errors
> - Remember that the PowerShell ISE will allow you to highlight multiple lines of PowerShell code and run them together by pressing **F8**

===
# Exercise 1: Pipeline Input

**Windows PowerShell** cmdlets are easy to discover, and use. Their real power is unleashed when two or more commands are connected together using the pipeline operator **|**.

## Objectives

After completing this exercise, you will be able to:

- Identify the pipeline character
- Provide pipeline input
- Process and filter pipeline items to produce desired output

===

# Task 1.1: Get-\* commands

There are a number of ways to provide pipeline input. The **Get-\*** commands are designed for this purpose.

1. [] Sign in to **win10(wdt** as **+++Power+++** using **+++Pa$$w0rd+++** as the password.

1. [] Open the Windows PowerShell ISE by right clicking on the PowerShell icon and selecting &quot;Run ISE as an Administrator, or by clicking @[Run ISE as Administrator.][AdminPowerShellISE]{shell visible}.

1. [] List all the commands with the **Get-** verb, using **Get-Command**:

    ```PowerShell-notab
    Get-Command –verb Get
    ```

1. [] The pipeline can be used to count the total number of commands returned. To construct this pipeline, first find a cmdlet with the verb **Measure** that can be used to measure the number of objects on the pipe. Leverage +++Get-Command+++ to find this cmdlet. Which cmdlet would you use to measure these objects?

    <details>
    <summary>Hint</summary>

    ```PowerShell-notab
    Get-Command -verb measure
    ```
    </details>

    <details>

    <summary>Answer</summary>

    ```PowerShell-notab
    Measure-Object
    ```
    </details>

1. [] Use that cmdlet on the pipeline to return the total number of **Get-** commands.

    <details>
    <summary>Answer</summary>

    ```PowerShell-notab
    Get-Command –verb Get | Measure-Object
    ```
    </details>

1. [] What is the number of **Get-** commands found?

    <details>
    <summary>Answer</summary>

    It differs per system, as more or less PowerShell modules are present, but aproximately 600 &quot;Get-&quot; commands should be available on these lab machines.
    </details>

1. [] Construct pipeline commands to answer the following questions using Knowledge gained from previous steps.

    - [] Measure the total number of commands of type **cmdlet** in your current **Windows PowerShell ISE** session.

        <details>
        <summary>Answer</summary>

        ```PowerShell-notab
        Get-Command -CommandType Cmdlet | Measure-Object
        ```
        </details>

    - [] Measure the total number of commands of type **Application** in your current **Windows PowerShell ISE** session.

        <details>
        <summary>Answer</summary>

        ```PowerShell-notab
        Get-Command -CommandType Application | Measure-Object
        ```
        </details>

1. [] **Measure-Object** can be used to interact with properties that contain numbers, such as file sizes. List all the files in **C:\\Windows\\System32** by running this code:

    ```PowerShell-notab
    Get-ChildItem –Path C:\Windows\System32 -File
    ```

    >[!Knowledge] Note the use of the **-File** switch parameter to only return files.

1. [] Using a **pipeline** with **Measure-Object**, calculate the **sum** of all file sizes in **C:\\Windows\\System32**. The file size property is called **Length**

    >[!Tip] Use **Get-Help** on **Measure-Object** to determine which parameters are required to return the **sum**

    <details>
    <summary>Answer</summary>

    ```PowerShell-notab
    Get-ChildItem C:\Windows\System32 -File | Measure-Object -Property length -sum
    ```
    </details>

===

# Task 1.2: File & External Command Input

A common use of the **Windows PowerShell** pipeline is to process text files and text returned by external **Windows** commands.

This task will use two common cmdlets for these actions.

**Get-Content** reads a text file line by line and sends each line as a separate string along the pipeline.

**Select-String** is similar to grep in UNIX or findstr.exe in Windows. It is used to check if a pattern is present in a string, then returns that string if the pattern exists.

1. [] To fetch some data from a log file on the DC machine, execute the following command:

    ```PowerShell-notab
    Get-Content -Path &#39;\\DC\C$\Windows\debug\DCPROMO.LOG&#39;
    ```

1. [] Thinking back to the knowledge in the last task, what pipeline command would you use to measure the number of lines in the file? Construct and execute the command.

    <details>
    <summary>Answer</summary>

    ```PowerShell-notab
    Get-Content -Path &#39;\\DC\C$\Windows\debug\DCPROMO.LOG&#39; | Measure-Object
    ```
    </details>

1. [] **Measure-Object** has some parameters geared towards measuring information in files. How would you count the number of **lines** (excluding empty lines), **words**, and **characters** in the file?

    >[!Tip] Perform a **Get-Help** for the **Measure-Object** command to investigate its parameters

    <details>
    <summary>Answer</summary>

    ```PowerShell-notab
    Get-Content &#39;\\DC\C$\Windows\debug\DCPROMO.LOG&#39; | Measure-Object -Line -Word -Character
    ```
    </details>

1. [] Another common administrative task is searching within text files for keywords. **Select-String** command is available for this purpose. Search the **DCPROMO.LOG** file for all instances of the string **dsrole**, using the command below:

    ```PowerShell-notab
    Get-Content -path &#39;\\DC\C$\Windows\debug\DCPROMO.LOG&#39; | Select-String –Pattern &#39;dsrole&#39;
    ```

    Notice that a small subset of strings are returned, as it is only displaying strings that contain &quot;DsRole&quot;
    >[!Knowledge] The **pattern** parameter takes a [regular expression](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_regular_expressions?view=powershell-7) string pattern used to find strings within the object coming through the pipeline. Regular expressions are **not covered** in this course, but the cmdlet can be used on literal characters like it was in this step. For more information on regular expressions you can run: **Get-Help about_Regular_Expressions**

1. [] **Select-String** is also useful to parse external command output since each line of text output to the console is turned into a string object. Type and execute the following command:

    ```PowerShell-notab
    ipconfig /all | Select-String -Pattern &#39;Ipv4 Address&#39;
    ```

1. [] Execute a **Get-Help** for the **Select-String** cmdlet to view what other options exist within the cmdlet:

    ```PowerShell-notab
    Get-Help Select-String -full
    ```

1. [] How would you search for multiple patterns, such as **Ipv4 Address** and **Subnet Mask**, using the same command from the previous step?

    <details>
    <summary>Answer</summary>

    ```PowerShell-notab
    ipconfig /all | Select-String -Pattern &#39;Ipv4 Address&#39;, &#39;Subnet Mask&#39;
    ```
    </details>

===

# Exercise 2: Sorting & Selecting

Once data has been acquired using the **Get-\*** commands, one of the many operations that can be performed is to sort the data and select subsets.

**Windows PowerShell** is aware of the type of data it is processing, and sorts it appropriately. For example, **strings** sort alphabetically and numbers numerically - even dates and times sort in the correct date or time order. More complicated objects will use a default property, such as *name*.

## Objectives

After completing this exercise, you will be able to:

- Sort different types of objects based on their property values.
- Select subsets of data on the pipeline

===
# Task 2.1: Sorting by Column Headers

1. [] Execute the following command:

    ```PowerShell-notab
    Get-ChildItem –Path C:\Windows
    ```
     Scroll up to the top of the list in the console pane and you should find the same column header names as listed in this image:

    ![PowerShell](Media/1.png)

    Notice the data is sorted on the *name* property by default.
    > [!Knowledge] Column headers are the names of the  properties of the objects that are being shown.

1. [] +++Sort-Object+++ can be used on the pipeline to sort data using specific property names. Use +++Sort-Object+++ to sort the +++Get-ChildItem –Path C:\Windows+++ data in the following ways:
    - [] Sort the data by the *Length* property

        <details>
        <summary>Answer</summary>

        ```PowerShell-notab
        Get-ChildItem –Path C:\Windows | Sort-Object –Property Length
        ```
        </details>

    - [] Sort the data by the *LastWriteTime* property

        <details>
        <summary>Answer</summary>

        ```PowerShell-notab
        Get-ChildItem –Path C:\Windows | Sort-Object –Property LastWriteTime
        ```
        </details>
    > [!Knowledge] Notice the data is sorted in *ascending* order. Example, alphabetical from a-z, numerical from smallest to largest, and dates are from oldest to newest.

1. [] The default behavior is to sort data in *ascending* order, but it can be swapped to *descending* order. Perform a similar action to the last step, but this time sort the output by the *name* property in *descending* order.

    > [!Tip] Use **Get-help** for **Sort-Object** to find which parameter forced *descending* order

    <details>
    <summary>Answer</summary>

    ```PowerShell-notab
    Get-ChildItem –Path C:\Windows | Sort-Object –Property Name -Descending
    ```
    </details>

1. [] Sort the results of +++Get-Hotfix+++ by the property **InstalledOn**

    <details>
    <summary>Answer</summary>

    ```PowerShell-notab
    Get-Hotfix | Sort-Object –Property InstalledOn
    ```
    </details>

> [!Knowledge] The procedure of first executing the command, without any arguments, in order to view the default column headers is a good way to view what default header values are displayed.

> [!knowledge] The **Get-Hotfix** cmdlet, while works in Windows PowerShell 5 and above, it does not work on older Operating Systems of 2008/2008R2 as the location of the hot fixes on the OS has been modified in the newer OS&#39;s to work with the newer cmdlet. Thus, while the cmdlet will work with the proper PS version on an older OS, it will not produce any results and will not have any errors presented.

===

# Task 2.2: Selecting Properties and Lists

**Select-Object** has many uses, such as:
 - Selecting properties
 - displaying a subset of the first or last items in a list
 - filtering out duplicate entries.

1. [] Explore the available parameters for **Select-Object** using auto-complete or help data.

    ```PowerShell-notab
    Get-Help Select-Object -ShowWindow
    ```

1. [] Using +++Get-Service+++ and +++Select-Object+++ List the *displayName*, *status*, and *starttype* properties of all services:

    <details>
    <summary>Answer</summary>

    ```PowerShell-notab
    Get-Service | Select-Object –Property DisplayName, Status, StartType
    ```
    </details>

1. [] The pipeline can leverage multiple cmdlets. For example, +++Sort-Object+++ can send its output to +++Select-Object+++ for more detailed data filtering.

    Write a line of code that uses +++Get-Process+++, +++Sort-Object+++, and +++Select-Object+++ to **sort** the processes based on the **handles** property in **descending** order *then* **select** the *first 5* processes.
    <details>
    <summary>Hint</summary>

    To sort the processes by the handles property, in descending order:
    ```PowerShell-notab
    Get-Process | Sort-Object handles -Descending
    ```
    </details>

    <details>
    <summary>Answer</summary>

    ```PowerShell-notab
    Get-Process | Sort-Object handles -Descending | Select-Object -First 5
    ```
    </details>

1. [] The order you write cmdlets on the pipeline is the order they occur in and it is very important to keep that in mind. This code is similar to the answer above:

    ```PowerShell-notab
    Get-Process | Select-Object -First 5 | Sort-Object handles -Descending
    ```
    - [] Execute the code and observe the results. Do the results match the answer to the previous answer?

        <details>
        <summary>Answer</summary>

        No
        </details>

    - [] Why is this the case?

        <details>
        <summary>Answer</summary>

        The first line sorts highest resource handles then picks the top five. The second line selects the first 5 before a sort. Thus, you have to be very careful on what you&#39;re looking for as the top 5 of the most used resource handles, not just 5 of them.
        </details>

1. [] Return the **first 10 errors** from the **System event log**. The **Get-Eventlog** command returns entries in date order by default, therefore sorting is not required:

    <details>
    <summary>Answer</summary>

    ```PowerShell-notab
    Get-EventLog -Logname System –EntryType Error | Select-Object -First 10
    ```
    </details>

1. [] Note the duplicate process names in the output of the **Get-Process** command. Remove duplicate process names with Select-Object&#39;s **-Unique** switch parameter by running this code:

    ```PowerShell-notab
    Get-Process | Select-Object -Property Name -Unique
    ```

    >[!Knowledge] The **Unique** parameter is very useful if you only need a list of names/items that could contain duplicates. Thus providing just the names/items of actual interest if not needing to worry about multiple entries. There is also a [Get-Unique](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/get-unique?view=powershell-7) cmdlet to perform other unique querying options.

1. [] Construct pipeline commands to return the following information. Ensure the commands return the correct information.

    1. [] List the **10** processes that have the most open **Handles**.

        <details>
        <summary>Possible Answer 1</summary>

        ```PowerShell-notab
        Get-Process | Sort-Object –Property Handles -Descending | Select-Object -First 10
        ```
        </details>

        <details>
        <summary>Possible Answer 2</summary>

        ```PowerShell-notab
        Get-Process | Sort-Object –Property Handles | Select-Object -Last 10
        ```
        </details>

    1. [] List the **five** most recently modified files in **C:\\Windows**, based upon the time they were last written.

        <details>
        <summary>Answer</summary>

        ```PowerShell-notab
        Get-ChildItem -Path C:\Windows -file | Sort-Object -Property LastWriteTime -Descending | Select-Object -First 5
        ```
        </details>

    1. [] List the **10** oldest events in the **Application log**, with entry type **Information**.

        <details>
        <summary>Answer</summary>

        ```PowerShell-notab
        Get-EventLog -Logname Application –EntryType Information | Select-Object -Last 10
        ```
        </details>

===
# Halfway point!

You have successfully completed these two exercise of this first section for the **Pipeline module**.

Please pause here until the instructor completes the next lecture portion.

If your instructor said to do all of this Pipeline module, continue on to exercise 3.

Click **Next** to advance to the next exercise.

===

# Exercise 3: Formatting & Grouping

**Windows PowerShell** includes a number of formatting cmdlets to display data in convenient ways.

The default display format varies by cmdlet, but is generally a table or list. This can be easily modified, as this may not be optimal when viewing some types of data.

Because the default format does not include every property of an object, these cmdlets allow you to display ones that are normally hidden.

The formatting cmdlets should be the final stage in a pipeline operation (right-hand most command) as the view from the pipeline to the screen is the ending result.

## Objectives

After completing this exercise, you will be able to:

- Output objects properties in different formats on the console.

===
# Task 3.1: Displaying data in a table format

1. [] **Format-Table** uses the **-Property** parameter to select the property **names** of the objects to display in the tables columns. Run the following code to see the cmdlet in action:

    ```PowerShell-notab
    Get-Service | Format-Table -property Name, DependentServices
    ```

1. [] Modify the command above to display the **DisplayName** and **Status** columns.

    <details>
    <summary>Answer</summary>

    ```PowerShell-notab
    Get-Service | Format-Table -property DisplayName, Status
    ```
    </details>

    >[!Note] Use **Get-help** to find any additional parameters to find what you&#39;re looking for.

1. [] **Format-Table** has a number of useful parameters. The **-GroupBy** parameter will group results into separate tables. Sorting the data is required prior to grouping a property. Type and run the commands below:

    ```PowerShell-notab
    Get-Service | Sort-Object –Property StartType | Format-Table -Property Name, Status, StartType -GroupBy StartType
    ```

    ```PowerShell-notab
    Get-Process | Sort-Object -Property SessionId | Format-Table -GroupBy SessionId
    ```

1. [] Using **Sort-Object** and **Format-Table** with the **-GroupBy** parameter, write a command that:
    - Gets files and folders in **C:\Windows**
    - Sort and group by the **Attributes** property
    - Displays the **Attributes**, **LastWriteTime**, **Length** and **Name** columns.

    <details>
    <summary>Answer</summary>

    ```PowerShell-notab
    Get-ChildItem C:\Windows | Sort-Object –Property attributes | Format-Table -GroupBy attributes -Property attributes, lastwritetime, length, name
    ```
    </details>

===

# Task 3.2: Displaying data in a formatted list view

Sometimes a table does not provide sufficient space to present the data in which to show the desired results. A list format can usually solve this problem. **Windows PowerShell** provides the **Format-List** cmdlet for this purpose.

**Format-List** will produce a list of properties for *every* object it sees on the pipeline.

1. [] Type the following command:

    ```PowerShell-notab
    Get-Process
    ```

1. [] Notice the default behavior is a Format-Table. How many columns are displayed?

    <details>
    <summary>Answer</summary>

    Eight: Handles -- NPM(K) -- PM(K) -- WS(K) -- CPU(s) -- Id -- SI -- ProcessName
    </details>

1. [] Since a Format-List will provide a large amount of data vertically, this command will grab only the first one to explore how the Format-List looks. Type the following commands:

    ```PowerShell-notab
    Get-Process | Select-Object -First 1 | Format-List

    Get-Process | Select-Object -First 1 | Format-List –Property *
    ```

    >[!Knowledge] The wildcard character (*) forces **Windows PowerShell** to display all properties for each process.

1. [] Sometimes objects have hidden properties, and the `-force` parameter can be used to display them. Type the following command:

    ```PowerShell-notab
    Get-Process | Select-Object -First 1 | Format-List –Property * -force
    ```
    >[!Tip] This isn&#39;t very common to need, but it can come in handy to be aware of.

1. [] How many more properties can you see for each process?
    >[!Tip] To count the properties, you can use the **Measure-Command**

    <details>
    <summary>Answer</summary>

    The number of propertis are : 67
    ```PowerShell-notab
    (Get-Process | Select-Object -First 1 | Measure-Object -Property *).count
    ```
    </details>

===

# Task 3.3: Grouping Data

**Group-Object** is a cmdlet used to *group* data up based on the value of a particular property. If two objects on the pipeline have the same value for a **specified** property, they are placed in the same group.

1. [] The following command groups the newest written **1000 eventlog** entries by **EntryType**. Since **EntryType** only has a small number of values that will occur (**error**, **warning**, and **information**) this can be a great way to organize data. Run this command:

    ```PowerShell-notab
    Get-Eventlog -LogName system –newest 1000 | Group-Object -Property EntryType
    ```

    >[!Note] The resulting object is a [GroupInfo Object](https://docs.microsoft.com/en-us/dotnet/api/microsoft.powershell.commands.groupinfo?view=pscore-6.2.0). By the end of the course you&#39;ll be able to use this to grab the individual groups as well.


1. [] Using **Group-Object** and **Get-Service**, get all **Services** and group them by the **status** property.

    <details>
    <summary>Answer</summary>

    ```PowerShell-notab
    Get-Service | Group-Object -Property status
    ```
    </details>

1. [] Now, using the same cmdlets, get all **Services** and group them by the **StartType** property.

    <details>
    <summary>Answer</summary>

    ```PowerShell-notab
    Get-Service | Group-Object -Property StartType
    ```
    </details>

1. [] Time to put a lot of the skills together. Use a pipeline command to:

    - **Get** the files from **C:\\Windows\\System32**
    - **Group** them by file extension
    - **Sort** the result by the **Count** property in  **descending** order
    - **Select** the **first five** results. Using your knowledge from these recent steps, what would the code be?

    <details>
    <summary>Answer</summary>

    ```PowerShell-notab
    Get-ChildItem C:\Windows\System32 -file | Group-Object -Property extension | Sort-Object -Property Count -Descending | Select-Object –first 5
    ```
    </details>

1. [] What was the most common file extension in **C:\Windows\System32**?

    <details>
    <summary>Answer</summary>

    .dll
    </details>

    >[!Tip] You should be starting to see the power of **PowerShell** and the quickness that the cmdlets can run. If you are asked to provide specific information about a server or service, this is the foundation of what is possible. In the next exercise, you will see that you&#39;ll be able to import a list or specific content into these commands to provide information on whatever is in the list. For example, 10, or 1000, or 10,000 machines and then output that content into a readable file or many different format options.

===

# Exercise 4: Pipeline Output

**Windows PowerShell** has a number of commands to write pipeline processed data into files and convert it to other structured file formats, such as **html**, **csv**, **JSON**, or **xml**.

## Objectives

After completing this exercise, you will be able to:

- Send data from the pipeline out to files in different formats
- Convert several different types of objects to structured data such as JSON or CSV
- Import data from files in various formats to use on the pipeline

===

# Task 4.1: Export to a Text File

Sending pipeline output to a text file is a common operation. **Out-File** is a helpful pipeline cmdlet to make this happen.

1. []  Type the following external command and review its output.

    ```PowerShell-notab
    driverquery
    ```

1. [] Using **Select-String**, extend this command to find any line of text containing **&quot;File System&quot;**

    <details>
    <summary>Answer</summary>

    ```PowerShell-notab
    driverquery | Select-string –Pattern &#39;File System&#39;
    ```
    </details>

1. [] Write the resulting matches to a text file using the **Out-File** cmdlet. Type the command below then open and review the file: **C:\PShell\Labs\drivers.txt**.

    ```PowerShell-notab
    driverquery | Select-string –Pattern &#39;File System&#39; | Out-File –FilePath C:\PShell\Labs\drivers.txt
    ```

1. [] Although the data is in a text file, you can perform further pipeline processing. Construct a single pipeline command to perform the following tasks:
    - Read the data from the file created above: *C:\PShell\Labs\drivers.txt*
    - Leverage **Select-String** to find any line continaing **&#39;SMB&#39;**
    - Write the content to a file named: *C:\\PShell\\Labs\\SMB_drivers.txt file*.

    <details>
    <summary>Answer</summary>

    ```PowerShell-notab
    Get-Content –Path C:\PShell\Labs\drivers.txt | Select-String –Pattern &#39;SMB&#39; | Out-File –FilePath C:\PShell\Labs\SMB_Drivers.txt
    ```
    </details>

===

# Task 4.2: Exporting and Importing CSV Information

The previous task performed pipeline operations on lines of text and saved the output in unstructured text files. This task will focus on writing and reading structured Comma-Separated Value (**CSV**) files. The data from this file could be displayed in an application, such as Excel, and can even be **imported** into other scripts.

The cmdlets **Export-CSV** and **Import-CSV** will be used to accomplish these tasks.

1. [] Exporting **CSV** data is very straightforward and can be a convenient way to generate **reports** that can be viewed in **Excel** or any csv viewer of choice.

    Use +++Get-Service+++ and +++Export-CSV+++ on the pipeline to send all the services to a file named +++C:\PShell\Labs\services.csv+++

    <details>
    <summary>Answer</summary>

    ```PowerShell-notab
    Get-Service | Export-Csv -Path C:\PShell\Labs\services.csv
    ```
    </details>

1. [] Navigate to the file to ensure it exists. Feel free to open it and inspect the contents. Notice that the top line shows type information, but you could leave this out with **-NoTypeInformation**. This information only matters if you plan to bring that data back into PowerShell.

    `#TYPE System.ServiceProcess.ServiceController`
    >[!Knowledge] Excel is **not** installed on the lab machines, but if you want to see how this file is rendered by a csv viewer you could get an extension for VSCode. If you&#39;re not comfortable with this, just move to the next step.

    <details>
    <summary>View in VSCode</summary>
    Run this command

    ```PowerShell-notab
    code C:\PShell\Labs\services.csv
    ```

    Click the extension button

    ![VsCode1](Media/VSCode1.png)

    Type csv and choose an extention to install. There are many. At the time writing this &quot;Edit CSV&quot; was chosen.

    ![VsCode2](Media/VSCode2.png)

    Right click and choose &quot;Edit as CSV&quot;

    ![VsCode3](Media/VSCode3.png)

    ![VsCode4](Media/VSCode4.png)

    </details>

1. [] Using **Import-CSV**, import the file created in the previous step located at +++C:\PShell\Labs\services.csv+++. View it as both a list and a table.

    ```PowerShell-notab
    Import-Csv C:\PShell\Labs\services.csv | Format-Table
    Import-Csv C:\PShell\Labs\services.csv | Format-List
    ```

1. [] The data should look a little different than when you run `Get-Service` on its own. When the data is changed to text and back there can be some changes to it. Generally, all the properties (information) are preserved unless they are lists of data, such as the *DependantServices* property. Methods, however, are almost always removed. Pipe the data to **Get-Member** and pay special attention to the *TypeName* at the top, and the available *methods*.

    ```PowerShell-notab
    Import-Csv C:\PShell\Labs\services.csv | Get-Member
    ```

1. [] **Import-Csv** can be used on files without type information to create custom objects. This can be incredibly useful for writing automated tools in the real world when you receive data as a CSV. Take a look at the file +++C:\PShell\Labs\services.csv+++, then use the pipeline to **import** it to a **Format-List**

    ```PowerShell-notab
    Import-Csv C:\PShell\Labs\services.csv | Format-List
    ```

1. [] **Import** the same file, but pipe it to **Get-Member** and look at the **typename** at the top.

    ```PowerShell-notab
    Import-Csv C:\PShell\Labs\services.csv | Get-Member
    ```

1. [] Using **Import-CSV** and **Sort-Object**, sort the **services** in the file by *Name*

    <details>
    <summary>Answer</summary>

    ```PowerShell-notab
    Import-Csv C:\PShell\Labs\services.csv | Sort-Object -Property Name
    ```
    </details>

===
# Task 4.3: Working with JSON content

JavaScript Object Notation (**JSON**) is a lightweight data-interchange format that is easily readable and is easy for machines to parse and generate. Many API&#39;s, including Microsoft Graph API for Microsoft 365, use **JSON** file formats for many tasks. **PowerShell** can easily and quickly **convert** content to and from PowerShell objects to JSON.

**ConvertTo-Json** and **ConvertFrom-Json** will be used to accomplish these tasks.

1. [] Using **Get-Service** and **ConvertTo-Json** on the pipeline you can convert the **Bits** service to JSON format. Notice the text will just come back to the console.

    ```powershell-notab
    Get-Service bits | ConvertTo-Json
    ```

1. [] Extend the previous command using **Out-File** to create a JSON file +++C:\PShell\Labs\Bits.json+++ that might be consumed by another application.

    ```powershell-notab
    Get-Service bits | ConvertTo-Json | Out-File C:\PShell\Labs\Bits.json
    ```

1. [] To read in an input of a **JSON** file, **Get-Content** and **ConvertFrom-Json** and be used. Run this code to digest the content previously created:

    ```powershell-notab
    Get-content C:\PShell\Labs\Bits.json | ConvertFrom-Json
    ```
1. [] APIs, such as the Microsoft Graph API, return data in JSON format. The Graph API is outside of the scope of the course, but using **Invoke-WebRequest** and the *free API* &quot;Cat Facts&quot;, you can explore this experience. By fetching some data:

    ```powershell-notab
    $CatFact = Invoke-WebRequest -URI &#39;https://catfact.ninja/fact&#39; -Method Get -UseBasicParsing
    $CatFact
    ```

1. [] The data might seem overwhelming, but the **JSON** is stored in the *Content* property:

    ```powershell-notab
    $CatFact.Content
    ```

1. [] Just like with the **JSON** data from the bits file, this can be **converted** on the **pipeline** and explored with **Get-Member**:

    ```powershell-notab
    $CatFact.content | ConvertFrom-Json | Get-Member
    ```

1. [] Explore the members on the object, then store the *converted* data back into **$CatFact** and look at the *fact* property.

    ```powershell-notab
    $CatFact = $CatFact.content | ConvertFrom-Json
    $CatFact.fact
    ```

===

# Task 4.4: View Output in an Interactive Table

**Windows PowerShell** is an interactive, command-driven environment. The **Out-GridView** cmdlet allows the user to sort, select, and query pipeline data within a graphical user interface (GUI).

1. [] Run **Get-Help** for the **Out-GridView** cmdlet and take a look at the **-PassThru** parameter:

    ```powershell-notab
    Get-Help Out-GridView -ShowWindow
    ```

1. [] The **-PassThru** parameter allows content to be selected in the **GUI**. That content can get passed back into PowerShell. The content can even move down the pipeline to the next cmdlet.

    This command will allow you to select data from the interactive GUI and send that data down the pipe into **Export-CSV**:

    ```PowerShell-notab
    Get-Hotfix | Out-GridView –Passthru | Export-Csv –Path C:\PShell\Labs\hotfixes.csv
    ```

1. [] In the **gridview**, sort by clicking on the **Description** column header.

1. [] Add a filter criteria to display **Descriptions** that contain the string **Security**.

1. [] Select any three rows using **Ctrl** + **left mouse-click**

    > [!Tip] You can use **Shift** + **click** to multi-select just like you can in the file explorer.

1. [] Press the **OK** button at the bottom-right of the grid view window. This will now create the **CSV** file with only the selected content.

1. [] Import the csv file **C:\\PShell\\Labs\\hotfixes.csv** and display the contents in table format. Are the rows you selected in the grid-view in now in the file?

    <details>
    <summary>Answer</summary>


    ```PowerShell-notab
    Import-Csv C:\PShell\Labs\hotfixes.csv
    ```

    Yes. the output from the **Out-Gridview** including the filtering was passed along the pipeline to the **Export-Csv** cmdlet.
    </details>

===
# Task 4.5: Importing and Exporting as XML

Extensible Markup Language (**XML**) is a common structured data storage format that lends itself well to describing the type of data **Windows PowerShell** commands exchange. Just like with **CSV** data, PowerShell can **Export** *and* **Import** these **XML** files.

One of the reasons to use **XML** over **CSV** can be seen when a *property* of an object contains an array (list) of data. The **XML** format can maintain a list of the array content within a propety, whereas **CSV** format will only present the object type and not the array values themselves.

**XML** can present a **hierarchical** display of content deeper and more precise than **CSV** files can. This task will focus on showing the difference between the two.

1. [] Get the **Spooler** service object and export the values to a file in **XML** format:

    ```PowerShell-notab
    Get-Service -Name Spooler | Export-Clixml C:\PShell\Labs\Spooler.xml
    ```

1. [] Get the **Spooler** service object and export the values to a file in **CSV** format:

    ```PowerShell-notab
    Get-Service -name Spooler | Export-Csv C:\PShell\Labs\Spooler.csv
    ```

1. [] Review the *ServicesDependedOn* property of the **Spooler** service. The next steps will compare this data to the data exported to **XML** and **CSV**

    ```PowerShell-notab
    (Get-Service -Name Spooler).ServicesDependedOn
    ```

1. [] Load the two exported files into their own variables for comparison of the output:

    ```PowerShell-notab
    $dataXML = Import-Clixml C:\PShell\Labs\Spooler.xml

    $dataCSV = Import-Csv C:\PShell\Labs\Spooler.csv
    ```

1. [] Call the **ServicesDependedOn** property of each file type and notice the different values:

    ```PowerShell-notab
    $dataXML.ServicesDependedOn

    $dataCSV.ServicesDependedOn
    ```

1. [] What did the **XML** value show?

    <details>
    <summary>Answer</summary>

    It showed the complete correct depended upon services: **RPCSS** - Remote Procedure Call (RPC) with its&#39; status and the **http** - HTTP Service with its&#39; status.
    </details>

1. [] What did the **CSV** value of the *ServicesDependedOn* attribute show?

    <details>
    <summary>Answer</summary>

    It only presented the object **type** and not the nested details that the **XML** content displayed. The type listed of: **System.ServiceProcess.ServiceController[]**
    </details>

===

# Task 4.6: Creating an HTML File (Optional)

A common requirement for IT professionals is to produce easily accessible reports. **CSV** files can be great for this, but aren&#39;t always ideal.

**Windows PowerShell** makes this process easy with the **ConvertTo-Html** cmdlet, which creates an html table from pipeline data.

1. [] Get a list of **Hot Fixes**, sort them by **InstalledOn** date property, in **descending** order, and convert the data to an html table, by running this code:

    <details>
    <summary>Answer</summary>

    ```PowerShell-notab
    Get-HotFix | Sort-Object -Property InstalledOn -Descending | ConvertTo-Html
    ```
    </details>

1. [] Is this easily readable in its current view?

    <details>
    <summary>Answer</summary>

    No
    </details>

1. [] Now output the content into a readable file by running this code:

    <details>
    <summary>Answer</summary>

    ```PowerShell-notab
    Get-HotFix | Select-Object -Property Description, hotfixid, installedon | Sort-Object -Property InstalledOn -Descending | ConvertTo-Html | Out-File -FilePath C:\PShell\Labs\hotfix.html
    ```
    </details>

1. [] View the page by running this code:

    ```powershell-notab
    Start-Process c:\PShell\Labs\hotfix.html
    ```

    > [!Knowledge] **Start-Process** on an HTML file should launch the default web browser on the machine or prompt a selection regarding what application to use on HTML files. This is handy to put in remarks or references to web sites in PowerShell files to provide additional context for end users.

===

# Congratulations student!

You have successfully completed this module.

There is an optional self test on the **next** page.

To mark the lab as complete, take the test and click **End**.

===

# Self test (Optional part of the course)

## Self test information

The following self test is an optional part of this course and can be used to evaluate if your knowledge of the subject matter is sufficient. You can use this self test to re-evaluate your knowledge after taking the course or test your knowledge before you take / retake the course.

This self test uses 10 questions and or exercises. To get a fair result you should complete this self test using your knowledge only and not using any internet search engines.

##  Self test duration

Although the self test is not timed this test should be completed in approximately 15 minutes.

To start the self test continue to the next page.

===

## Self test

1. <Removed>
___
2. <Removed>
___
3. <Removed>
___
4. <Removed>
___
5. <Removed>
___
6. <Removed>
___
7. <Removed>
___
8. <Removed>
___
9. <Removed>
___
10. <Removed>




">
    <input type="hidden" id="activities" value="[]">
    <input type="hidden" id="replacementTokens" value="[{&quot;Token&quot;:&quot;@lab.LabProfile.Id&quot;,&quot;Replacement&quot;:&quot;38671&quot;},{&quot;Token&quot;:&quot;@lab.CtrlAltDelete&quot;,&quot;Replacement&quot;:&quot;&lt;a href=&#39;#&#39; class=&#39;ctrlAltDeleteLink&#39;&gt;Ctrl+Alt+Delete&lt;/a&gt;&quot;},{&quot;Token&quot;:&quot;@lab.VirtualMachine(WIN10).SelectLink&quot;,&quot;Replacement&quot;:&quot;&lt;a href=&#39;#&#39; class=&#39;selectMachineLink&#39; data-data=&#39;63124&#39;&gt;WIN10&lt;/a&gt;&quot;},{&quot;Token&quot;:&quot;@lab.VirtualMachine(WIN10).Username&quot;,&quot;Replacement&quot;:&quot;Power&quot;},{&quot;Token&quot;:&quot;@lab.VirtualMachine(WIN10).Password&quot;,&quot;Replacement&quot;:&quot;Pa$$$$w0rd&quot;},{&quot;Token&quot;:&quot;@lab.VirtualMachine(MS).SelectLink&quot;,&quot;Replacement&quot;:&quot;&lt;a href=&#39;#&#39; class=&#39;selectMachineLink&#39; data-data=&#39;54597&#39;&gt;MS&lt;/a&gt;&quot;},{&quot;Token&quot;:&quot;@lab.VirtualMachine(MS).Username&quot;,&quot;Replacement&quot;:&quot;Power&quot;},{&quot;Token&quot;:&quot;@lab.VirtualMachine(MS).Password&quot;,&quot;Replacement&quot;:&quot;Pa$$$$w0rd&quot;},{&quot;Token&quot;:&quot;@lab.VirtualMachine(DC).SelectLink&quot;,&quot;Replacement&quot;:&quot;&lt;a href=&#39;#&#39; class=&#39;selectMachineLink&#39; data-data=&#39;54598&#39;&gt;DC&lt;/a&gt;&quot;},{&quot;Token&quot;:&quot;@lab.VirtualMachine(DC).Username&quot;,&quot;Replacement&quot;:&quot;Administrator&quot;},{&quot;Token&quot;:&quot;@lab.VirtualMachine(DC).Password&quot;,&quot;Replacement&quot;:&quot;Pa$$$$w0rd&quot;},{&quot;Token&quot;:&quot;@lab.OpticalMedia(5638).LoadLink&quot;,&quot;Replacement&quot;:&quot;&lt;a href=&#39;#&#39; class=&#39;loadMediaLink opticalMedia&#39; data-data=&#39;5638&#39;&gt;Introduction to Commands - 0050&lt;/a&gt;&quot;},{&quot;Token&quot;:&quot;@lab.LabInstance.Id&quot;,&quot;Replacement&quot;:&quot;[ID]&quot;},{&quot;Token&quot;:&quot;@lab.LabInstance.GlobalId&quot;,&quot;Replacement&quot;:&quot;[lodID]&quot;},{&quot;Token&quot;:&quot;@lab.LabInstance.StartDate&quot;,&quot;Replacement&quot;:&quot;20190108&quot;},{&quot;Token&quot;:&quot;@lab.User.Id&quot;,&quot;Replacement&quot;:&quot;[USERID]&quot;},{&quot;Token&quot;:&quot;@lab.User.FirstName&quot;,&quot;Replacement&quot;:&quot;[FIRSTNAME]&quot;},{&quot;Token&quot;:&quot;@lab.User.LastName&quot;,&quot;Replacement&quot;:&quot;[LASTNAME]&quot;},{&quot;Token&quot;:&quot;@lab.User.Email&quot;,&quot;Replacement&quot;:&quot;[EMAIL]&quot;},{&quot;Token&quot;:&quot;@lab.User.ExternalId&quot;,&quot;Replacement&quot;:&quot;[EXTERNALID]&quot;},{&quot;Token&quot;:&quot;@lab.Tag&quot;,&quot;Replacement&quot;:&quot;[TAG]&quot;}]">

    <textarea id="copyInput" value="" style="position: absolute; left:-10000px; top:-10000px; "></textarea>

    <script type="text/javascript"> 
    
        String.prototype.replaceAll = function(search, replacement) {
            var target = this;
            return target.replace(new RegExp(search, 'g'), replacement);
        };

        var childWindows = [];

        function showClickFeedbackMessage(text, x, y, duration) {
            var $message = $("<div class='clickFeedbackMessage noselect'>" + text + "</div>");
            $message.appendTo($("body")).hide();
            $message.css({ left: x, top: y });
            $message.fadeIn("fast");
            window.setTimeout(function () {
                $message.fadeOut("fast", function () { $message.remove(); });
            }, duration);
        }

        function copyableClicked(element) {
            //only copy if we are clicking, not if we have used the mouse to select the text manually.
            var selectedText;
            if (window.getSelection) {
                selectedText = window.getSelection().toString();
            } else if (document.selection && document.selection.type !== "Control") {
                selectedText = document.selection.createRange().text;
            }
            if (selectedText) { return };

            var $element = $(element);
            var text = $element.text();
            $("#copyInput").val(text).select();
            var offset = $element.offset();
            var x = offset.left;
            var y = offset.top - 40;
            try {
                var successful = document.execCommand("copy");
                if (successful) {
                    showClickFeedbackMessage("Copied to clipboard", x, y, 2000);
                } else {
                    showClickFeedbackMessage("Copying was unsuccessful", x, y, 2000);
                }
            } catch (err) {
                showClickFeedbackMessage("Copying was unsuccessful", x, y, 2000);
                console.log("Unable to copy. " + err);
            }
        }

        function setupKnowledgeExpanders() {
            $(".knowledge").each(function () {
                var knowledge = this;
                var $knowledge = $(this);
                var $moreKnowledge = $knowledge.next();
                if ($moreKnowledge.is(".moreKnowledge")) {
                    var maxHeight = 100;
                    var leeway = 100;
                    var diff = knowledge.scrollHeight - maxHeight;
                    if (diff < leeway) {
                        $knowledge.removeClass("collapsed");
                        $moreKnowledge.find("a").hide();
                    } else {
                        //this is tall content, let's show the 'more' link
                        $moreKnowledge.find("a").show();
                        $knowledge.addClass("collapsed");
                    }
                }
            });
        }

        var variables = {};

        function processVariables() {
            $("span.variable").each(function () {
                var $this = $(this);
                var name = $this.attr("data-name");
                if (name in variables) {
                    $this.html(variables[name]);
                } else {
                    $this.text("<" + name + ">");
                }
            });
            $("input.variableTextBox").each(function () {
                var $this = $(this);
                var name = $this.attr("data-name");
                if (name in variables) {
                    $this.val(variables[name]);
                } else {
                    $this.val("");
                }
            });
            $("code").each(function () {
                var originalHtml = this.originalHtml ? this.originalHtml : this.innerHTML;
                var newHtml = originalHtml;
                for (var name in variables) {
                    var val = variables[name];
                    var regex = new RegExp('<span class="nocode">&lt;' + name + '&gt;</span>', 'g');
                    newHtml = newHtml.replace(regex, val);
                }
                if (originalHtml != newHtml || originalHtml != this.innerHTML) {
                    this.originalHtml = originalHtml;
                    this.innerHTML = newHtml;
                }
            });
        }
        
        window.onload = function () {

            var rawContent = document.getElementById("rawContent").value;
            var contentRoot = "./Content/"
            var activitiesString = document.getElementById("activities").value;
            var activities = (activitiesString == null || activitiesString.length == 0) ? [] : JSON.parse(activitiesString);
            var replacementTokensString = document.getElementById("replacementTokens").value;
            var replacementTokens = (replacementTokensString == null || replacementTokensString.length == 0) ? [] : JSON.parse(replacementTokensString);
            instructionsProcessor.process(rawContent, "instructions", false, contentRoot, replacementTokens,
                function ($page) {
                    setupKnowledgeExpanders();
                },
                activities
            );
            $(".page").each(function () {
                var $page = $(this);
                if ($page.find("iframe.externalManual").length > 0) {
                    $page.css("padding", 0);
                }
            });

            $("body").on("click", ".moreKnowledgeLink", function (e) {
                e.preventDefault();
                var $link = $(this);
                var $knowledge = $link.parent().prev();
                if ($knowledge.hasClass("expanded")) {
                    $knowledge.removeClass("expanded");
                    $link.text("more...");
                } else {
                    $knowledge.addClass("expanded");
                    $link.text("...less");
                }
            }).on("click", ".copyable, code:not(.nocopy)", function (e) {
                copyableClicked(this);
            }).on("click", ".dialogLink", function (e) {
                e.preventDefault();
                e.stopImmediatePropagation();
                var $dialogLink = $(this);
                var title = $dialogLink.attr("title");
                var target = $dialogLink.attr("data-target");
                if (target) {
                    var $hiddenDialog = $("blockquote.referenceContent[data-id='" + target + "']");
                    if ($hiddenDialog.length === 0) {
                        alert('CONTENT ERROR: Unable to find a reference content "' + target + '"');
                    } else {
                        showDialog({title:title, content: $hiddenDialog.html() });
                    }
                }
                else {
                    showDialog({title:title, url: $dialogLink.attr("href"), isInstructions: $dialogLink.hasClass("instructions") });
                }
            }).on("click", ".videoLink, video", function (e) {
                e.preventDefault();
                var videoUrl = $(this).hasClass("videoLink") ? this.href : this.src;
                var url = "./Content/" + videoUrl.split('Content/').pop().replace(/\#(.*?)$/, '').replace(/\?(.*?)$/, '')
                if (this.title) {
                    
                }
                var videoWindow = window.open(url, "videoWindow", "menubar=no,location=no,resizable=yes,scrollbars=yes,status=no");
                childWindows.push(videoWindow);
                try {
                    videoWindow.focus();
                } catch (e) {

                }
            }).on("click", ".imageLink, img", function (e) {
                var $this = $(this);
                if ($this.parent().is("a")) return;
                e.preventDefault();
                e.stopImmediatePropagation();
                var imgUrl = $this.hasClass("imageLink") ? this.href : this.src;
                var url = "./Content/" + imgUrl.split('Content/').pop().replace(/\#(.*?)$/, '').replace(/\?(.*?)$/, '')
                if (this.title) {
                    
                }
                var imageWindow = window.open(url, "imageWindow", "menubar=no,location=no,resizable=yes,scrollbars=yes,status=no");
                childWindows.push(imageWindow);
                try {
                    imageWindow.focus();
                } catch (e) {

                }
            }).on("click", ".tipLink", function (e) {
                e.preventDefault();
                var $tiplink = $(this);
                var $hiddenTip = $tiplink.next();
                var offset = $(this).offset();
                var x = offset.left;
                var y = offset.top + 25;
                showClickFeedbackMessage($hiddenTip.html().replaceAll('<code title="Copy to clipboard" class="prettyprint">','<code title="Copy to clipboard" style="background-color:#8888;" class="prettyprint">').replaceAll("class",'style="background-color:#8888;" class'), x, y, 5000);
            }).on("change", ".variableTextBox", function () {
                var $textBox = $(this);
                var name = $textBox.attr("data-name");
                var val = $textBox.val();
                if (val == null || val.length == 0) {
                    if (name in variables) {
                        delete variables[name];
                    }
                } else {
                    variables[name] = val;
                }
                processVariables();
            });;

            $(window).resize(function () {
                setupKnowledgeExpanders();
            }).unload(function () {
                closeAllChildWindows();
            });

            function closeAllChildWindows() {
                for (var i = 0; i < childWindows.length; i++) {
                    try {
                        childWindows[i].close();
                    } catch (e) {
                    }
                }
                childWindows = [];
            }

            function showDialog(options) {
                if (!options) return;
                var $dialog = $("#modalDialog");
                var isUpdatedContent = false;
                if ($dialog.length > 0) {
                    $dialog.find(".dialogContent").html("");
                    $dialog.find(".dialogButtons").html("");
                    isUpdatedContent = true;
                } else {
                    var $dialog = $('<div id="modalDialog" class="dialog"><div class="dialogMask"></div><div class="dialogBox"><div class="dialogCloseButton"></div><div class="dialogTitle"></div><div class="dialogContent"></div><div class="dialogButtons"></div></div></div>');
                }
                var $dialogBox = $dialog.find(".dialogBox");
                var close = function () {
                    var h = $dialogBox.outerHeight();
                    var offset = $dialogBox.offset();
                    $dialogBox.css("marginTop", 0).animate({ marginTop: -h - offset.top }, 300);
                    $dialog.delay(200).fadeOut("fast", function () { $dialog.remove(); });
                }
                $dialog.find(".dialogCloseButton").click(close);

                if (options.title) {
                    $dialog.find(".dialogTitle").html(options.title).show();
                } else {
                    $dialog.find(".dialogTitle").hide();
                    $dialog.addClass("noTitle");
                }
                if (options.content) {
                    $dialog.find(".dialogContent").removeClass("noScroll").append(options.content);
                } else if (options.url) {
                    var urlLower = options.url.toLowerCase();
                    if (urlLower.indexOf(".mp4") !== -1) {
                        $dialog.find(".dialogContent").removeClass("noScroll").append('<video src="' + options.url + '" controls autoplay></video>');
                        var $video = $("#contentDialogVideo");
                        try {
                            $video[0].play();
                        } catch (e) {
                            //
                        }
                    } else if (urlLower.indexOf(".png") !== -1 || urlLower.indexOf(".jpg") !== -1 || urlLower.indexOf(".jpeg") !== -1 || urlLower.indexOf(".gif") !== -1) {
                        $dialog.find(".dialogContent").removeClass("noScroll").append('<img src="' + options.url + '" controls></iframe>');
                    } else if (options.isInstructions || urlLower.indexOf(".md") !== -1) {
                        $dialog.find(".dialogContent").removeClass("noScroll").append('<div id="instructionsDialog"></div>');
                        window.setTimeout(function () {
                            instructionsProcessor.processUrl(options.url, "instructionsDialog");
                            if (options.url.indexOf("#") >= 0) {
                                window.setTimeout(function () {
                                    var hash = options.url.substr(options.url.indexOf("#"));
                                    var $element = $("#instructionsDialog " + hash);
                                    if ($element.length > 0) {
                                        $dialog.find(".dialogContent").scrollTop($element.position().top);
                                    }
                                }, 400); //leave time for the content to layout... the dialog takes 400ms to animate anyway, which should be sufficient.
                            }
                        }, 1);
                    } else {
                        $dialog.find(".dialogContent").addClass("noScroll").append('<iframe id="contentDialogIFrame" src="' + options.url + '" style="width:100%;height:100%;border:none;" allowfullscreen></iframe>');
                    }
                } else {
                    $dialog.find(".dialogContent").hide();
                }
                if (options.buttons && options.buttons.length > 0) {
                    $dialog.addClass("hasButtons");
                    var $dialogButtons = $dialog.find(".dialogButtons");
                    var numButtons = options.buttons.length;
                    for (var i = 0; i < numButtons; i++) {
                        var button = options.buttons[i];
                        var $button = $("<input type='button' value='" + button.text + "' />");
                        if (button.click) {
                            $button.click(button.click);
                        }
                        if (button.primary) {
                            $button.addClass("primary");
                        }
                        if (button.closeDialog) {
                            $button.click(close);
                        }
                        $dialogButtons.append($button);
                    }
                }
                if (!isUpdatedContent) {
                    $("body").append($dialog);
                    $dialog.hide().fadeIn("fast", function () {
                        if (options.open) {
                            options.open();
                        }
                    });
                    var h = $dialogBox.outerHeight();
                    var offset = $dialogBox.offset();
                    $dialogBox.css("marginTop", -h - offset.top).animate({ marginTop: 0 }, 400);
                }
                return {
                    close: close
                };
            }

        }

        function getScrollTop() {
            return document.body.scrollTop;
        }

    </script>


</body>
</html>
